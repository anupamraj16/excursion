// 1. start a server: a. connect config.env file b. check response in browser
// 2. use body parser. app.use(express.jason({limit : '10kb'}))
// 3. define resources, create URL handler functions, envelope response to mitigate security issues. Mount multiple routes so that routes go through app.js and then redirected to correct file. refactor code and use MVC architecture. chain multiple middlewares if required. serve static files. create other env variables
// 4. create and connect to database, create a data model with validators. change controllers to deal with DB
// * Another way of creating documents. const newTour = new Tour({place data here}); newTour.save() || Tour.create({place data here})
// 5. apply query filtering, req.query- create a hard copy (not just a reference) of queryObj using destructuring to filter out other parameters [page, sort, limit, fields]. first build the query and then execute it (do not consume the query right away with await in .find () so that pageing and sorting etc can be implemented)
    const tours = await Tour.find(req.query);
    const tours = await Tour.find({ duration: 5, difficulty: 'easy' });
    const tours = await Tour.find()
      .where('duration')
      .equals(5)
      .where('difficulty')
      .equals('easy');
// 6. advanced filtering: URL- localhost/api/v1/tours?duration[gte]=5. mongodb find object- {duration : {$gte : 5}}, req.query- duration : {gte : '5'}}. the difference between mongodb find object and req.query is $ and '' only. stringify the queryObj, implement for gte, gt, lte, lt using regex- queryStr.replace(/\b(gte|gt|lte|lt)\b/g, match => `$${match}`). get the queryObj back from the string
// 7. check for req.query.sort and apply sorting by .sort(req.query.sort). price for ascending and -price for descending. mongoose sorting object- sort('price ratingsAverage'). URL- localhost/api/v1/tours?sort=price,ratingsAverage
// 8. apply fields limiting. URL- localhost/api/v1/tours?fields=name,duration,difficulty,price. mongoose object- .select('name duration difficulty price'). exclude __v by .select('-__v'). fields can be excluded in schema itself by select : false
// 9. apply pagination by .skip(20).limit(10). URL- localhost/api/v1/tours?page=3&limit=10. define default values with || defaultValue. skip = (page - 1) * limit. check if requested page exists or not by checking .countDocuments()
// 10. apply aliasing in routes by using a middleware in controllers (prefill the query string by setting req.query.desiredQuery and call next())
// 11. repeat- refactor by using class APIFeatures {constructor (queryObj, queryString)}. one example of the queryObj could be Tour.find(). chain all the filtering, sorting, limiting and paginating queries at the end to get the result
// 12. aggregation pipeline. use await Tour.aggregate( [different stages- $match: {query object}, $group: { _id : }] )
// 13. unwinding and projecting. Tour.aggregate([ { $unwind : '$startDates' } ]), $month, $push, $addFields, $project uses 0/1, $limit
// 14. virtual properties. tourSchema.virtual('propertyName').get(function(){ return this.abcd }). add { toJSON: { virtuals : true}, toObject: { virtuals : true} } to the schema as schema options- 1st object is schema definitions, 2nd object is options
// *   Middlewares are called pre or post hooks in Mongoose. Save/Find is the Hook. Four type of middlewares in mongoose- document, query, aggregate, model. Middlewares are defined on schemas. pre middleware has this keyword, post doesn't
// 15. document middleware. tourSchema.pre('save', function(next) { this.slug = slugify( this.name, { lower : true } ) next()}). runs before .save() and .create() but not for insertMany(). pre document middleware has access to next(), post middleware has access to document that was just saved and next() both. post runs after all pre have been completed
// 16. query middleware. tourSchema.pre(/^find/, function(next) { this.find( { secretTour : { $ne : true } } ) next()}). .post(/^find/,....)
// 17. aggregation middleware. tourSchema.pre('aggregate', function(next)...). .pipeline().unshift( { $match : {secretTour : {$ne:true} } } )- adds aggregation object before the aggregation pipeline
// 18. data validation and custom validators. validate: {validator: function (val) {// this only points to current doc on NEW document creation return val < this.price;},message: 'Discoun price ({VALUE}) should be below regular price',}

// 19. ndb- add script in package.json=> "debug" : "ndb startPoint"
// 20. Handle unhandled routes. Positon this handler after all other route handlers. app.all('*', (req, res, next) => {res.status(404).json({status : 'fail', message : `Can't find ${req.originalUrl} on this server!`})})
// 21. Operational vs Programming errors and Global Error Handling Middleware. app.use((err, req, res, next) => { console.log(err.stack); err.statusCode = err.statusCode || 500; err.status = err.status || 'error'; res.status(err.statusCode).json{ status : err.status, message : err.message}})- provide 4 arguments and express will recognize this as an error handling middleware. as a second step create an error- const err = new Error('pass your message here'); err.status = 'fail'; err.statusCode = 404, next(err). if next has an argument, no matter what it is, express will automatically know that there was an error
// 22. Create customized error class in util folder as AppError by extending Error class and refactor the code. class AppError extends Error; constructor(message, statusCode) {super(message); this.statusCode = statusCode; this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error'; this.isOperational = true; Error.captureStackTrace(this, this.constructor)}. Put the newly created AppError into unhandled route handler middleware- app.all('*', (req, res, next) => {next( new AppError(`Can't find ${req.originalUrl} on this server`, 404))}). Put the global error handler function into controllers/errorController.js and use module.exports to export it, helper functions will not be exported.
// 23. Catch errors in async functions. Refactor the controllers so that they don't worry about handling errors and sending error responses. Take out try and catch blocks out, put them at a higher level in another function, wrap the async function into newly created catchAsync function
// 24. Add 404 errors
// 25. Error during development vs production. status, error, message, stack
// 26. Handle mongoose errors as operational errors. castError

// Authentication, Authorization & Security
// 1. Create User schema & model. For password- select : false
// 2. Create authController. exports.signup- a serious security flaw is there where anyone can pass malicious data to be an admin (create an object and use re.body properties to assign values). Create a route handler for signup
// 3. Manage passwords. Confirm password validator only works with .create() and .save(). Use a pre save hook/middleware to encrypt the password with bcryptjs. userSchema.pre(save, async function(next) { if (!this.isModified('password')) return next(); this.password = await bcrypt.hash(this.password, 12);this.passwordConfirm = undefined; next()})
// 4. Authentication with JWT. Server creates a JWT after login request. Client stores it in cookie or local storage. Stateless process. JWT- header (metadata about the token) + payload (data that can be encoded into the token) + signature (unique and encrypted using header, payload and the secret that is saved on the server)
// 5. Signing up users (Passport- a third party library can be used). Sign a new JWT and send it back to user to log him in. const token = jwt.sign( {id : newUser._id}, 'secret'). Define secret in config.env using HSA256 encryption (should be at least 32 characters long). JWT expiry can be passed in as an option { expiresIn : 90d }. Send the token along with the data to the client
// 6. Logging users in with user provided email and password. check if email and password exist in req.body. check if user exists and the password is correct. In userModel define an instance method which will be available on all user documents- userSchema.methods.correctPassword = async function(candidatePassword, userPassword) { return await bcrypt.compare(candidatePassword, userPassword) }. if everything is ok, send JWT to the client
// 7. Protect routes/resources. Place a authorization middleware before the controller in routes- getting token and check if it exists, validate the token, check if user still exists, check if user changed password after JWT was issued. Tokens are sent with HTTP header with the request. Set header- Authorization: Bearer JWT. Express turns the header name to lowercase. Promisify a function by using promisify obhect in util core module and then consume it with async await. verify the token- const decodedPayload = await promisify(jwt.verify)(token, secret). Handle new errors- invalid/expired JWT. const currentUser = await User.findById(decodedPayload.id). userSchema.methods.changedPasswordAfter = function(JWTTimestamp){}
// 8. Advanced Postman setup. Environments, {{URL}}. Command + S. Command + W. Tests- create {{JWT}}. Put JWT in Authorization tab with Bearer token
// 9. Authorization is verifying if a user has access/rights to certain resource. Implemented by using middlewares- restrictTo('admin', 'lead-guide'). To pass arguments in middleware- use wrapper function which will return the middleware function. The returned function will get access to arguments passed in the wrapper function because of closures. Protect middleware which has req.user = currentUser runs before restricTo. Role can be accessed from req.user.role
// 10. Password reset functionality- user sends a post request to reset password along with email address and a token (not JWT) is created and sent to the email that user provided. User then sends that token along with the new password. forgotPassword- get user based on POSTed email from req.body.email, generate the random reset token- in user model define a new instance method by using built in crypto module: const resetToken = crypto.randomBytes(32).toString('hex'); this.passwordResetToken = crypto.createHash('sha256').update(resetToken).digest('hex'); this.passwordResetExpires = Date.now() + 10 * 60 *1000; return resetToken, in authController- user.save({validateBeforeSave: false})/ saving partial document. send it to user's email- const resetURL = `${req.protocol}://${req.get('host')}/api/v1/users//resetPassword/${resetToken}`; const message = `Forgot your password? Submit a PATCH request with your new password and passwordConfirm to: ${resetURL}.\nIf you didn't forget your password, please ignore this email`; await sendEmail({email: user.email, subject: 'your password reset token (valid for 10 mins only), message'}); res.status(200).json({status: 'success', message: 'token sent to email'}). Use try catch block to assign undefined to user.passwordResetToken and user.passwordResetExpires and save the partial document with validationBeforeSave: false before sending it to global error handling middleware
// 11. Send emails with nodeMailer. util- email.js. sendEmail- const sendEmail = async options { //create a transporter: const transporter = nodemailer.createTransport({service: 'Gmail', auth: {user: ..., pass: ...}}) Activate 'less secure app' option in Gmail, Don't use Gmail, use SendGrid or MailGun. During development use Mailtrap. define email options: const mailOptions = {from: 'Anupam Raj <raj@gmail.com>', to: options.email, subject: options.subject, text: options.message}, send the email- await transporter.sendMail(mailOptions). resetPassword controller
// 12. Reset Password- get user based on the token. const hashedToken = crypto.createHash('sha256').update(req.params.token).digest('hex'); const user = await user.findOne({passwordResetToken : hashedToken}, passwordResetExpires : {$gt: Date.now()}). if token has not expired and there is an user, set the new password- user.password = req.body.password; user.passwordConfirm = ...; user.passwordResetToken/Expires = undefined. await user.save(). update changedPasswordAt property for the user. log user in and send JWT. for user we always use .save and not .update to use all the validator functions, and above all, all the middleware functions which encrypts the password among other things. Saving to DB is a bit slower that issueing a JWT
// 13. Update the current user password while logged in. authController.updatePassword- get user form collection- , check if POSTed current password is correct, if yes update the password, log user in and send JWT
// 14. Update user data while logged in. create error if user POSTs password data, update user document. REPEAT
// 15. Deleting user- set user to inactive. Hide inactive users from output using query middleware
// 16. Security best practices. Compromized DB- Strongly encrypt passwords with bcryptjs using salt and hash. Strongly encrypt password reset token (SHA256). Brute force attacks- Use bcrypt to make login requests slow. Implement rate limiting and maximum login attemps. Cross site scripting (XSS) attack- store JWT in HTTP only cookies (in client side XSS allows attacker to see local storage), sanitize user input data, set special HTTP headers (use helmet). Denial of Service attack- implement rate limiting, limit body payload, avoid evil regular expressions (takes exponential amount of time to run non-matching inputs and can be exploited to bring the application down). NOSQL Query Injection- use mongoose for mongodb (because of schema type), sanitize user input data
// 17. Send JWT via cookie. res.cookie.(nameOfCookie/'jwt', data/token, options/{ expires: in process.env, secure : true, httpOnly: true }). httpOnly- cookie can't be access or modified by the browser to avoid XSS attacks
// 18. Implement Rate Limiting using a middleware/express-rate-limit. const limiter = rateLimit({ max:100, windowMS: 60*60*1000, message: 'Too many requests from this IP in one hour, please try again later!!' }). app.use('/api', limiter)- this will affect all the routes starting with /api
// 19. Set Security HTTP Headers using helmet middleware- set early in middleware stack. app.use(helmet())
// 20. Data Sanitization after body parser against NoSQL query injection and XSS attacks. Example of NoSQL query injection- log in without email by providing { $gt: ''} in email field. app.use(mongoSanitize()). app.use(xss()). Prevent parameter pollution- app.use(hpp())- should be done after mongoSanitize and xss. Sometime duplicate properties are desired but hpp will prevent them, such as duration=5&duration=9 for tours having duration of 5 or 9 days- specify whitelist as an object in hpp. {whitelist: ['duration', 'ratingsQuantity', 'ratingsAverage', 'maxGroupSize', 'difficulty', 'price']}

// DATA MODELLING AND ADVANCED MONGOOSE
// 1. Data Modelling- converting unstructured real world data into structured and logical data model- area where a developer has to think the most. Steps- 1. different types of relations between data: 1 to 1, 1 to many (1 to few, 1 to many, 1 to ton), many to many 2. Referencing/normalization (child, parent and two-way (for many to many) referencing) vs embedding/denormalization 3. embedding or referencing other documents 4. types of referencing
// 2. Designing data model- tours, users, locations, reviews, bookings: assign data relations (1 to 1, few to few etc) to these data models. locations to be embedded into tours
// 3. Modeling Geospatial Data/Locations. MongoDB supports geospatial data out of the box in [long, lat] format. In tour model- startLocation: {type: {type: String, default: 'Point', enum: ['Point']}, coordinates: [Number], address: String, description: String }, locations: [{all other properties from startLocation, day: Number}]
// 4. Modelling Tour Guides by embedding- will not be implemented in this project. Do it in pre save middleware. tourSchema.pre('save', async function(next){const guidesPromises = this.guide.map(async id=>await User.findById(id)); this.guides = await Promise.all(guidesPromises); next()})
// 5. Modelling Tour Guides by child referencing. guides: [{type : mongoose.Schema.ObjectId, ref : 'User'}]
// 6. Populating Tour Guides/use this when there is a relationship between data, using populate will create a new query which will affect performance. To get access to tour guides whenever there is a query for tours- result will loook like as if the tour guide data has always been embedded. go to tourController and add to getTour: .populate('guides')-- .populate({path: 'guides', select: '-__v -passwordChangedAt'}). It will populate guides only in query and not in actual DB. Put the code in tourModel in a query middleware to populate all tours- tourSchema.pre(/^find/, function(next) => this.populate({...}); next())
// 7. Modelling Reviews by parent referencing- create reviewModel- review, rating, createdAt, ref to User, ref to Tour
// 8. Getting and Creating Reviews- getAllReviews, createReview. User needs to be logged in and hence user._id can be automatically captured from user object created by protect middleware
// 9. Populate Reviews with Tour and User data
// 10. Virtual Populate Tours with Reviews. Parent/Tour doesn't know about it's children/Reviews. Virtual populate can get all the reviews for a particular tour without keeping review id in tour document. In tourModel add a virtual property- tourSchema.virtual('reviews/nameOfTheVirtualField', {ref : 'Review', foreignField : 'tour', localfield : '_id'}). Update getTour- .populate('reviews'). Handle cycle of populates and turn off tour populate in review
// 11. Nested Routes. getting user id and tour id from the url and not define manually while creating reviews. POST /tour/tourId/reviews. GET /tpur/tpurId/reviews. GET /tour/tourId/reviews/reviewId
// 12. Nested Routes with Express- seperating reviews from tour routes using mergeParams (gives access to tourId parameter in reviewRoutes file). router = express.Router({ mergeParams: true }). router.use('/:tourId/reviews', reviewRouter)
// 13. Add a Nested GET Endpoint. Find all reviews on a tour
// 14. Build Handler Factory Functions in handlerFactory.js- generalize controllers
// 15. authController.protect protects all the routes comming after that
// 16. Add a /me Endpoint
// 17. Add Missing Authentication and Authorization
// 18. Import User and Review data. validateBeforeSave : false
// 19. Improve Read Performances with Indexes. add query.explain() for testing/reference in handler/controller. Compass- Indexes Tab. In tourModel- tourSchema.index({price: 1}). 1 for ascending, -1 for descending. Compound Index- tourSchema.index({price: 1, ratingsAverage: -1}). Indexes take a lot more space than documents itself. Indexes are not suitable for high write/read ratios ie where documents are updated frequently and thus indexes would need to be updated frequently too. Index slug. If an index is removed from code, it is not deleted from the DB, it has to be removed from DB manually
// 20. Calculate Average Rating on Tours by using aggregation pipeline- store a summary of a reated data set on the main data set. In reviewModel create a new function which will take in a tourId and calculate the averageRatings and ratingQuantity that exists in collection for that tour, the function will update the corresponding tour document. To use this function, use a middleware each time a review is created, updated or deleted. So far we have used instance methods, this time static method will be used. Static methods can be called on models directly- Review.calcStats. In reeviewModel- reviewSchema.statics.calcAverageRatings = async function(tourId) {const stats = awaitthis***1.aggregate([{$match : {tour:tourId}}, $group: {_id: '$tour', nRating: {$sum: 1}, avgRating: {$avg: '$rating'}}. ])}. ***1 this keyword points to the current model, aggregate needs to be called on the model directly and that is why we are using static method. post middleware doesn't get access to next. reviewSchema.post('save', function() {// this points to current review, we want to callthe calcAverageRating function using this.tour. function is available on the model- Review.calcAverageRatings(this.tour)- Problem is: Review variable is not yet defined, simple solution would be move the code after creation of Review Model but that will not work. Because just like in Express this code is going to run in a sequence in which it s declared and it will not be part of reviewSchema. There is a way around it. this.constructor.calcAverageRatings(this.tour)}). Persist the calculated stats in tourModel- await Tour.findByIdAndUpdate(tourId, {ratingsAverage: stats[0].avgRating, ratingsQuantity: stats[0].nRating}). check stats[0]
// 21. Calculate Average Rating on Tours when review is updated or deleted. Trickier because it uses findByIdAndUpdate/Delete- there is no document middleware for these methods, only query middleware is available which doesn't have access to current document. Workaround- use a pre-middleware for these events- reviewSchema.pre(/^findOneAnd/, async function(next) {//the goal is to get the current review document, but this keyword will give the current query. To go around- execute a query and that will give the current review document// const r = await this.findOne(); next()}). This previous line of code will not save the document to the DB and ratingsAverage will not be currect without updated reviews (findOne() only gets the document from the DB), and using post-middleware is not an option as query will already have been executed. We are only interested in the tourId of the current review document and now we can use the calcAverageRatings function, or can we? If we use the calcAverageRatings function at this point of time, we will calculate the statistics using non-updated data. Earlier we used post with calcAverageRatings while creating the document, here we can't use post instead of pre-middleware because the query would have been returned with post-middleware. Solution is to add another post-middleware: reviewSchema.post(/^findOneAnd/, async function() {await this.r.constructor.calcAverageRatings(this.r.tour)}). To pass data from pre to post-middleware, instead of saving the current document to a simple variable r- save it to this.r. calcAverageRatings is a static method and need to be called on the model, this.r.constructor is the model here. If else block for stats[0]- while deleting last review it throws an error
// 22. Prevent Duplicate Reviews- prevent a user from writing multiple reviews for the same tour. Use a compound index- tourId + userId. In reviewModel after schema definition- reviewSchema.index({tour: 1, user: 1}, {unique: true}). In tourModel- ratingsAverage- set: val => Math.round(val * 10)/10 to round the ratingsAverage to 1 decimal point
// 23. Geospatial Queries: Finding Tours Within Radius. router.route('/tours-within/:distance/center/:latlng/unit/:unit').get(tourController.getToursWithin). exports.getToursWithin = catchAsync(async (req, res, next) => {const {distance, latlng, unit} = req.params; const [lat, lng] = latlng.split(','); const radius (convert to radians) = unit === 'mi' ? distance/3963.2 : distance/6378.1; if (!lat || !lng) {next(new AppError('Please provide latitude and longitude in a format [lat, lng]', 400))}; const tours = await Tour.find({ startLocation: {$geoWithin: {$centerSphere: [[lng, lat(notice the format)], radius]}} }); send response/data}). Important- in order to be able to do just basic queries, we need to first attribute an index to the field where the geospatial data that we are searching for is stored ie add an index to the startLocation. In tourModel- tourSchema.index({startLocation: '2dsphere'}). Here 1 or -1 is not used because in geospatial data we use 2dshpere (if the data describes real points on a earth like sphere) or 2d index if we are using fictional points on a 2D plane. In compass- analyze schema
// 24. Geospatial Aggregation- Calculating Distances from a certain point to all the tours. In order to do calculations we always need aggregation pipeline and it is called on the model itself. router.route('/distances/:latlng/unit/:unit').get(tourController.getDistances). exports.getDistances = catchAsync(async((req, res, next) => {const {latlng, unit} = req.params; const [lat, lng] = latlng.split(','); if (!lat || !lng) {next(new AppError('...', 400))}; const distances = await Tour.aggregate([$geoNear: {near: {type: 'Point', coordinates: [lng * 1, lat * 1]}, distanceField: 'distance/this is the name of field that will be created and all the distances will be stored'}])})). For geospatial aggregation there is only one single stage that actually exists and always needs to be the first one in the pipeline- $geoNear. It also requires that at least one of our fields contains a geospatial index. If there is only one field with geospatial index then the geoNear stage will automatically use that index to perform calculation, if there are multiple fields with geospatial indexes then keys parameters should be used to define fields to perform calculations. distanceMultiplier : 0.001. $project: {distance: 1, name: 1}. const multiplier = unit === 'mi' ? 0.000621371 : 0.001

// SERVER SIDE RENDERING
// 1. Setup Templating Engine In Express- Pug/ejs/handlebars. Tell express which templating engine we are going to use- app.set('view engine', 'pug'). Pug templates are called views in express. Tell express where views are located- app.set('views', path.join(__dirname, 'views')). Use path.join and avoid ./ and ${__dirname}. We don't always know whether a path that we recieve from somewhere already have a / or not ./ is relative path. psth is a core Node module. Put static file serving middleware right after views engine  definition as they work closely. In views folder create base.pug. app.get('/', (req, res) => {res.status(200).render('base')})
// 2. Starting with Pug. Pug is a whitespace sensitive syntax for writing HTML. Attributes go inside paranthesis. Always with single quotes. Regular HTML code can also be read in pug. Each of the assest triggers its own HTTP request. These assests don't have a route handler- it works because of the static file serving middleware. Reference to stylesheet is still a route because it's a get request. To pass data into template- define an object in res.render('base', {tour: 'ABC', user: 'XYZ'}). The variables passed here (tour and user) are called locals in pug file. In pug file- h1= tour. There are two kinds of comments in Pug- //Comment will be visible in console. //-Comment will not be visible in client. Simple JavaScript can be run in Buffered Code- code that is going to add something to the output. h2= user.toUpperCase(). Unbuffered code- not going to add anything to the output=> -const x = 9. Interpolation- #{variable}. title Natours | #{tour}- string is added to Natours. Can't do title= Natours | #{tour} because anything after = is treated as JavaScript code
// 3. Create Base Template. Convert overview.html to pug file. To specify a class just start with dot(.). To specify text content- start with space. div.header__logo is same as .header__logo. div is standard block element in HTML. Needing an extra line can be converted to code on same line with colon. Copyright
// 4. Including Files into Pug Templates- break the base template code into different files to avoid repeatative code. Prefix file names with _ that only serve for being included ie _header.pug. While copying and pasting indentation can be messed up- Pug Beautify extension for VS Code (be careful with this one- messes sometimes). In base.pug- include _header. Same for footer
// 5. Extend the Base Template with Blocks by using extends. Create overview.pug and tour.pug and create routes for these to be rendered. In base.pug put a block content. In overview.pug extends base. block content. Each file can only extend one other file but can have multiple blocks in each of the files. Base template has all the skeleton but not page specific content. Overview and Tour contain page specific contents. Extend is opposite of Including. In include- parent includes the children, in extend- children extends the parent
// 6. Refactor. Create viewRoutes.js
// 7. Building the Tour Overview. In controller- get tour data from collection, build template, render that template by passing data from step 1. Create a tourCardTemplate.pug. //each tour in tours// will loop cards for all tours. Assign dynamic data to pug file by using equal sign (=). alt expects a string and can't use = sign to assign alternate text for image, use ES6 template strings. tour.startDates[0].toLocaleString('en-us', {month: 'long', year: 'numeric'}). Use | to create space between two elements in pug
// 8. Build the Tour Page. Mixins in Pug- reusable pieces of code in which arguments can be passed, just like functions. mixin overviewBox(label, text, icon).... use mixin: +overviewBox(XYZ, ABC, DEF). Conditionals in Pug are very simple and don't even allow checking for equality, but JavaScript can be used with - sign. Repeat lecture 184
// 9. Include a Map with Mapbox- runs in frontend, we will write JavaScript fro client side and integrate it into templates. Public folder is available on client side- code will go into js folder, create mapbox.js. Best place to integrate mapbox.js is in base template, but we only want to implement map on tour page- solution is to extend a block in base template. When we extend a block the content inside that block disappears. There is another way of extending blocks which will simply add new content at the end or the begining of the block. At the begining of tour template- block append/prepend(at the begining) foot script(src='/js/mapbox.js'). To get access to the location data of the tour that we are trying to display in mapbox.js. We can do an AJAX request that is basically an API call and get the data from there, but that's not really neccessary in this case. In tour template we have all the data about the tour itself and now we can simply put that data into our HTML so that JavaScript can read it from there. So basically we are going to expose the location data right here in the string as HTML and JS will pick it up from there without having to do any API call separately. In map section, it has a div element with amp class with an id #map. We can specify a data attribut here. This is a trick in JS where we can specify a data attribut in HTML and then read that attribute in JS in a very easy way. In HTML we can't have arrays but only text/string. #map(data-locations=`${JSON.stringify(tour.locations)}`).In mapbox.js- const locations = JSON.parse(document.getElementById('map').dataset.locations). Go to mapbox and use CDN to integrate it with the app. Put the CDN in tour template in block append head. Copy the JS code into mapbox.js. To suit mapbox code where container is set to map, HTML contains an id map. That is where the map will be placed in HTML on an element with an id map. That's it and we are good to go- it will give a world map where we need to plot our tours. Go to mapbox design studio- create new style and use. Copy the style URL and paste into mapbox.js where style is defined. define center: [lng, lat] just like mongoDB format, zoom: 4, interactive: false. We don't want map to center anywhere but want it to figure out the tour locations and show that. const bounds = new mapboxgl.LngLatBounds(); locations.forEach(loc => {//Add Marker const el = document.createElement('div'); el.className = 'marker'; new mapboxgl.Marker({element: el, anchor: 'bottom'}).setLngLat(loc.coordinates).addTo(map); bounds.extend(loc.coordinates)}). Create marker, add marker, extend map bounds to include current location. map.fitBounds(bounds, padding: {top:200, bottom:150, left:100, right:100}). To add popup to display information- new mapboxgl.Popup({offset:30}).setLngLat(loc.coordinates).setHTML(`<p>Day ${loc.day}: ${loc.description}</p>`).addTo(map). scrollZoom:false
// 10. Render Login Screen
// 11. Logging in Users Using Login API- make frontend and backend interact. A cookie is sent by server to the client after log in request and this cookie will be sent by client with each subsequent request. create new file in public/js/login.js. document.querySelector('.form').addEventListener('submit', e => { e.preventDefault(); const email = document.getElementById('password').value; login() }). Use axios. Only modern browsers can handle async await. const login = async (email, password) => {const res = await axios({method: 'POST', url: 'provide url here', data: {email, password}})}. Whenever there is an error axios will trigger an error- put code into try catch block. In axios documentation err.response.data. To get access to a cookie in app.js we need to install cookie-parser. use next to body-parser. req.cookies. use cookie to protect our routes by adding cookie reading to authController.protect which only reads JWT which starts with Bearer- else if (req.cookies.jwt){token: req.cookies.jwt}. Now with this we are also able to authenticate users  based on tokens sent via cookies and not only the authorization header
// 12. Remove login button and add user photo, bundle frontend code. Use conditional rendering in pug. To know if the user is logged in or not use a middleware. In authController modeify the protect middleware- there will never be an error in this new middleware. For rendered pages the jwt will be sent usnig only cookies and never by authorization header (only for API). If there is a logged in user we want him to give access to our templates. Each and every pug template will have access to res.locals and whatever we put on res.locals will be a variable and will be available in the pug template. res.locals.user = currentUser. If there is no cookie it simply means that there is no logged in user. Put the newly created middleware in viewRoutes before all other middlewares so that every request will go through it. In _header.pug use a conditional to switch between login and logout buttons. next() should be called once in isLoggedIn. There are two ways of sending data directly from an HTML form to node app- first is using HTTP request and the other one is to use HTML form directly. if(re.data.status === 'success'){window.setTimeout(() => {location.assign('/')}, 1500)}
// 13. Creating Alerts. Create alert.js in public/js. Alternarive to Webpack is Parcel-bundler --save-dev. Use script "watch:js": "parcel watch ./public/js/index.js --out-dir ./public/js --out-file bundle.js". Use script "build:js" with same path for production. The index.js file will be the entry file so in this file we get data from user interface and then delegate actions to some functions coming from the other modules. Export syntax worke little bit differently in Node and JavaScript. In index.js- import {login} from ('./login'). Install axios as the CDN has been commented out. Install a polyfill which will make some JS features work in older browsers- npm i @babel/polyfill. In index.js import '@babel/polyfill'. Again, index.js is more for getting data from user interface and delegate actions to some functions. CDN version of mapbox has some issues with parcel, so use npm version. Test the code where we assigned map on an element in HTML- if the map element exists in HTML. Repeat
// 14. Logging Out Users. So far we have deleted the cookie from browser which holds the jwt, but we created that cookie as an HTTP only cookie which means we can't manipulate the cookie in any way in the browser- can't change and can't delete. Solution is to send another cookie with same name but without jwt whenever the user clicks logout button- this will replace the cookie with the jwt and the user will be logged out, also this logout cookie will be send with a very short expiration time. In user routes define a GET route because we are not going to send any data with the request- we will simply get a cookie. Repeat
// 15. Render Error Page. req.originalUrl is basically the entire url without the host. Change sendErrorDev to handle errors with api and with rendered pages
// 16. Build User Account Page
// 17. Update User Data. Need to parse req.body which is coming from HTML form- put this next to body-parser=> app.use(express.urlencoded({extended: true, limit: '10kb'}))
// 18. Update User Data with API. Create public/js/updateSettings.js
// 19. Update User Password with API. Clear input fields after updating password

// ADVANCED FEATURES: PAYMENTS, EMAIL, FILE UPLOADS
// 1. Image Uploads With Multer. Multer is a middleware to handle multi-part form data which is a form encoding that is used to upload files from a form. In last section we used a URL encoded form to update user data and for tha twe included a middleware. Configure a multer upload and after that we can use it. In userRoutes const upload = multer({dest: 'public/img/users'}). Without destination option image will be uploaded into memory and not on the disc. Use upload to create a middleware function that we can put in updateMe route. router.patch('/updateMe', upload.single('photo'//name of the field that will hold the file), userController.updateMe). upload.single will also put some information on req object req.file req.body. Body parser is not able to handle files and that is why only name is assigned to req.body
// 2. Configure Multer- give images a better name and allow only image files to be uploaded on the server. Move multer related stuff from router to controller. Create multer storage and multer filter. We can also choose to store the image file in memory as a buffer so that we can use it later in other processes. const multerStorage = multer.diskStorage({destination: (req, file, cb) => {cb(null, 'public/img/users')}}, filename: (req, file, cb) => {const ext = file.mimetype.split('/')[1]}, cb(null, `user-${req.user.id}-${Date.now()}.${ext}`)). const multerFilter = (req, file, cb) => {if (file.mimetype.startsWith('image')){cb(null, true)}; else {cb(new AppError('Not an image! Please upload an image file', 400), false)}}. const upload = multer({storgae: multerStorage, fileFilter: multerFilter})
// 3. Save Image Name to DataBase. Update the filterBody variable- if (req.file) filteredBody.photo = req.file.filename. New user will not have a photo in the begining, in userModel define a default value for user photo
// 4. Resize image. Add a middleware to process image before updateMe and add to the route. change multerStorage = multer.memoryStorage() to store the file in buffer so that it can be resized by Sharp before saving it to server. exports.resizeUserPhoto = (req, res, next) => {if (!req.file) return next(); req.file.filename = `user-${req.user.id}-${Date.now()}.jpeg`; sharp(req.file.buffer).resize(500, 500).toFormat('jpeg').jpeg({quality : 90}).toFile(`public/img/users/${req.file.filename}`); next()}. Multiple methods can be chained to process the image- first one is resize
// 5. Add Image Uploads to Form
// 6. Adding Multiple Images
// 7. Processing Multiple Images
// 8. Building A Complex Image Handler
// 9. Email Templates With Pug
// 10. Sending Password Reset Emails
// 11. Using Sendgrid for Real Emails
// 12. Credit Card Payments With Stripe
// 13. Integrating Stripe Into BackEnd
// 14. Processing Payments on The FrontEnd
// 15. Modelling the Bookings
// 16. Creating New Bookings On CheckOut Success
// 17. Rendering A User's Booked Tour
// 18. Finishing the booking API
// 19. Finishing Touch. Implement restriction that a user can only review the tour they have actually booked. Implement nested routes- all bookings for a tour /tours/:id/bookings, all bookings for a user users/:id/bookings. Improve tour date- add participants, add sold out. In authentication and authorization section- confirm email by sending a link and only after that a user is registered, keep users logged in with refresh tokens, two factor authentication. On website- add signup page, prevent duplicate bookings, add like button functinality, add my reviws page for the user. Consume API with React

// * User.findByIdAndUpdate()- this.propoerty is not defined while updating the document because mongoose doesn't keep the current object/document in memory
// * .isModified, .isNew
// * req.params, req.body, req.query, req.headers, req.user (additional data can be added to req by manipulating it with middlewares), process.env, process.argv, process.exit(),



// checkID function is no longer needed as we will use ID from mongoDB now
// great example for param middleware
// exports.checkID = (req, res, next, val) => {
//   // param middleware function gets access to a fourth argument- val
//   // this is a kind of local mini application, will not work for users as it is defined in tourController
//   console.log(`Tour id is: ${val}`);

//   if (req.params.id * 1 > 10) {
//     // tours.length
//     return res.status(404).json({
//       // return finishes the req res cycle and response is send
//       status: 'fail',
//       message: 'Invalid ID',
//     });
//   }
//   next();
// };

// checkBody function is no longer needed as mongoose schema will be used to validate data
// exports.checkBody = (req, res, next) => {
//   if (!req.body.name || !req.body.price) {
//     return res.status(400).json({
//       status: 'fail',
//       message: 'Missing name or price',
//     });
//   }
//   next();
// };




165. await User.create(users, { validateBeforeSave: false }); // to turn off validators because saving users without validating, also turn off password encryption middlewares in userModel to skip encrypting password
